<!doctype html>
<html>
  <head>
    <title>Hornse Survival</title>
    <style>
      body {
        background-color: rgb(50, 200, 30);
        margin: 0px;
        padding: 0px;
      }
      #canvas1 {
        display: block;
        position: absolute;
        top: 0px;
        left: 0px;
        z-index: -1;
        image-rendering: pixelated;
        background-color: rgb(50, 200, 30);
      }
    </style>
  </head>
  <body>
    <h1 id="test">// // //</h1>
    <canvas id="canvas1"></canvas>
    <img hidden id="player" src="images/bestHornse.png" />
    <img hidden id="miniMap" src="images/miniMap.png" />
  </body>
</html>

<script>
  //CANVAS STUFF
  const canvas = document.getElementById("canvas1");
  const ctx = canvas.getContext("2d");
  canvas.width = window.innerWidth;
  canvas.height = window.innerHeight;

  const playerImage = document.getElementById("player");
  const miniMapImage = document.getElementById("miniMap");
  let playerState = "idle";
  let mapState = "center";

  let gameFrame = 0;
  const staggerFrames = 20;
  const spriteAnimations = {
    idle: {
      loc: [{ x: 0, y: 0 }],
    },
    walk: {
      loc: [
        { x: 200, y: 0 },
        { x: 400, y: 0 },
      ],
    },
    upLeft: {
      loc: [{ x: 0, y: 0 }],
    },
    upCenter: {
      loc: [{ x: 256, y: 0 }],
    },
    upRight: {
      loc: [{ x: 512, y: 0 }],
    },
    centerLeft: {
      loc: [{ x: 0, y: 256 }],
    },
    center: {
      loc: [{ x: 256, y: 256 }],
    },
    centerRight: {
      loc: [{ x: 512, y: 256 }],
    },
    bottomLeft: {
      loc: [{ x: 0, y: 512 }],
    },
    bottomCenter: {
      loc: [{ x: 256, y: 512 }],
    },
    bottomRight: {
      loc: [{ x: 512, y: 512 }],
    },
  };

  let playerX = 0;
  let playerY = 0;

  const testText = document.getElementById("test");
  let keysDown = {};
  let accelX = 0;
  let accelY = 0;
  const accelCap = 0.75;
  const accelInc = 0.01;
  const friction = 0.005;

  function animate() {
    ctx.clearRect(0, 0, canvas.width, canvas.height);
    // function position(state) {
    //   let fix;
    //   if (state === "walk") fix = 1;
    //   else fix = 0;
    //   return (
    //     (Math.floor(gameFrame / staggerFrames) %
    //       spriteAnimations[state].loc.length) +
    //     fix
    //   );
    // }
    // let pFrameX = 200 * position(playerState);
    // let mFrameX = 256 * position(mapState);

    let pFrameX = 0;
    if (playerState === "walk") {
      pFrameX =
        (Math.floor(gameFrame / staggerFrames) %
          spriteAnimations[playerState].loc.length) *
          200 +
        1;
    } else if (playerState === "idle") {
      pFrameX =
        (Math.floor(gameFrame / staggerFrames) %
          spriteAnimations[playerState].loc.length) *
        200;
    }
    let mFrameX = pFrameX;
    let mFrameY = 0;
    // (image, sourceX, sourceY, sourceWidth, sourceHeight, displayX, displayY, displayWidth, displayHeight)
    ctx.drawImage(
      playerImage,
      pFrameX,
      0,
      200,
      200,
      playerX,
      playerY,
      100,
      100,
    );
    ctx.drawImage(miniMapImage, mFrameX, mFrameY, 256, 256, 1220, 0, 128, 128);
    gameFrame++;
    requestAnimationFrame(animate);
  }
  window.onload = animate();

  function runTest() {
    testText.innerText =
      Math.floor(playerX) +
      " : " +
      Math.floor(playerY) +
      " : " +
      accelX +
      " : " +
      accelY;
    +" : " + playerState;
  }

  //KEY UP AND KEY DOWN
  document.addEventListener("keydown", (e) => {
    if (!keysDown[e.code]) {
      keysDown[e.code] = true;
    }
    runTest();
    movementCalc();
    runTest();
  });
  document.addEventListener("keyup", (e) => {
    keysDown[e.code] = false;
    runTest();
    movementCalc();
    runTest();
  });

  function movementCalc() {
    //POSITION CHANGE
    playerX += accelX;
    playerY += accelY;
    //VELOCITY Y
    if (accelY > -accelCap && accelY < accelCap) {
      if (keysDown.KeyW) {
        accelY += -accelInc;
      }
      if (keysDown.KeyS) {
        accelY += accelInc;
      }
    } else {
      if (accelY < accelCap) {
        accelY = -accelCap;
      } else {
        accelY = accelCap;
      }
      if (keysDown.KeyW) {
      }
      if (keysDown.KeyS) {
      }
    }
    //FRICTION Y
    if (
      (keysDown["KeyW"] && keysDown["KeyS"]) ||
      (!keysDown["KeyW"] && !keysDown["KeyS"])
    ) {
      if (Math.abs(accelY) < 0.05) {
        accelY = 0;
      } else if (accelY > 0) {
        accelY += -friction;
      } else if (accelY < 0) {
        accelY += friction;
      }
    }
    //VELOCITY X
    if (accelX > -accelCap && accelX < accelCap) {
      if (keysDown.KeyA) {
        accelX += -accelInc;
      }
      if (keysDown.KeyD) {
        accelX += accelInc;
      }
    } else {
      if (accelX < accelCap) {
        accelX = -accelCap;
      } else {
        accelX = accelCap;
      }
      if (keysDown.KeyA) {
      }
      if (keysDown.KeyD) {
      }
    }
    //FRICTION X
    if (
      (keysDown["KeyA"] && keysDown["KeyD"]) ||
      (!keysDown["KeyA"] && !keysDown["KeyD"])
    ) {
      if (Math.abs(accelX) < 0.05) {
        accelX = 0;
      } else if (accelX > 0) {
        accelX += -friction;
      } else if (accelX < 0) {
        accelX += friction;
      }
    }

    //Player State
    if (Math.abs(accelX) === 0 && Math.abs(accelY) === 0) {
      playerState = "idle";
    } else {
      playerState = "walk";
    }
  }

  setInterval(() => {
    movementCalc();
    runTest();
  }, 1);
</script>
